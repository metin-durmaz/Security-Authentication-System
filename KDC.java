import java.io.*;
import java.net.*;
import java.security.*;
import java.util.*;
import javax.crypto.*;

/**
 * KDC Class
 **/
public class KDC {

    private static String KDCPassword;
    private static PrintWriter logFile;                         // Attributes
    private static ServerSocket serverSocket;

    /**
     * KDC Main
     **/
    public static void main(String[] args) throws Exception {

        serverSocket = new ServerSocket(3000);
        directoryCreator();
        passwordGenerator();
        while (true)                                            // Server will run continuously
            serverSide();
    }

    /**
     * Creates a directory named CERT.
     * It creates 5 different certificates for 5 different classes by using keyTool commands in this directory.
     * Creates a directory named KEYS.
     * It creates 5 different .txt files for 5 different classes into this directory.
     * It prints the private keys of each class into the files.
     **/
    private static void directoryCreator() throws Exception {
        File certDirectory = new File("cert");
        certDirectory.mkdir();
        String[] keyStoreNames = {"ClientKeyStore", "KDCKeyStore", "MailKeyStore", "WebKeyStore", "DatabaseKeyStore"};
        String[] certNames = {"ClientCert", "KDCCert", "MailCert", "WebCert", "DatabaseCert"};
        for (int i = 0; i < 5; i++) {
            certificateGenerator(keyStoreNames[i], certNames[i], certDirectory.getAbsolutePath());
        }

        File privateKeyDirectory = new File("keys");
        privateKeyDirectory.mkdir();
        String[] priKeyNames = {"ClientPriKey", "KDCPriKey", "MailPriKey", "WebPriKey", "DatabasePriKey"};
        for (int i = 0; i < 5; i++) {
            PrivateKey privateKey = CryptFunctions.getPrivateKeyFromJKS(keyStoreNames[i]);
            PrintWriter keyFile = new PrintWriter(privateKeyDirectory.getAbsolutePath() + File.separator + (priKeyNames[i] + ".txt"));
            keyFile.write(Base64.getEncoder().encodeToString(privateKey.getEncoded()));
            keyFile.close();
        }
    }

    /**
     * Runs the functions in the keytool library through the terminal. KeyPair file
     * with .jks extension is created with the -genkey command. Certificate file
     * with .cer extension is created with the -export command.
     *
     * @param keyPairName --> keyPair File
     * @param certName    --> certificate File
     * @param certDir     --> certificate directory
     **/
    private static void certificateGenerator(String keyPairName, String certName, String certDir) throws Exception {

        String[] keyPairCommand = {"keytool", "-genkeypair", "-alias", keyPairName, "-keyalg", "RSA", "-keystore",
                keyPairName + ".jks", "-keypass", "metindurmaz", "-storepass", "metindurmaz", "-keysize", "2048",
                "-validity", "365", "-dname", "CN=metin, OU=metin, O=metin, L=metin, S=metin, C=metin"};
        Process keyPairProcess = Runtime.getRuntime().exec(keyPairCommand);
        keyPairProcess.waitFor();

        String[] certCommand = {"keytool", "-exportcert", "-alias", keyPairName, "-storepass", "metindurmaz",
                "-keystore", keyPairName + ".jks", "-rfc", "-file", certDir + File.separator + certName + ".cert"};
        Process certProcess = Runtime.getRuntime().exec(certCommand);
        certProcess.waitFor();
    }

    /**
     * Generates a 10 character alphanumeric password.
     * It sends the password to the function for hashing and prints it to the passwd file.
     **/
    private static void passwordGenerator() throws Exception {

        logFile = new PrintWriter(new FileWriter("KDC_Log.txt", true));
        PrintWriter passwdFile = new PrintWriter("passwd");
        int leftLimit = 48, rightLimit = 122;
        Random random = new Random();
        KDCPassword = random.ints(leftLimit, rightLimit + 1).filter(i -> (i <= 57 || i >= 65) && (i <= 90 || i >= 97))
                .limit(10).collect(StringBuilder::new, StringBuilder::appendCodePoint, StringBuilder::append).toString();

        passwdFile.write(CryptFunctions.SHA1Hash(KDCPassword));
        logFile.println(CryptFunctions.timeStampGetter() + " [" + KDCPassword + "]");
        passwdFile.close();
        logFile.close();
    }

    /**
     * Allows the server to accept new clients.
     * It decrypts the encrypted text from the client with its own secret key.
     * From the decrypted text, it takes the password entered by the user and compares it with the password generated by the KDC class.
     * If the passwords do not match, it asks the client to enter the password again.
     * If the passwords match, it creates a session key for the continuation of the session. Using this key, it creates a ticket.
     * Sends the encrypted text and ticket back to the client.
     **/
    private static void serverSide() throws Exception {

        logFile = new PrintWriter(new FileWriter("KDC_Log.txt", true));
        Socket clientSocket = serverSocket.accept();
        BufferedReader serverInput = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));
        PrintWriter serverOutput = new PrintWriter(clientSocket.getOutputStream(), true);

        while (true) {
            String encryptedClientMessage = serverInput.readLine();
            logFile.println(CryptFunctions.timeStampGetter() + " Alice->KDC : \"Alice\", " + encryptedClientMessage.substring(6));

            String decryptedClientMessage = CryptFunctions.decryptRSA(encryptedClientMessage.substring(6), CryptFunctions.getPrivateKeyFromTXT("KDCPriKey"));
            String[] words = decryptedClientMessage.split(",");
            logFile.println(CryptFunctions.timeStampGetter() + " Message Decrypted : \"Alice\", " + "[" + words[1] + "], " + words[2] + ", " + words[3]);

            if (!words[1].equals(KDCPassword)) {
                logFile.println(CryptFunctions.timeStampGetter() + " KDC->Alice : \"Password Denied\"");
                serverOutput.println("FALSE");
            } else {
                logFile.println(CryptFunctions.timeStampGetter() + " KDC->Alice : \"Password Verified\"");
                String sessionKey = sessionKeyGenerator();

                String TS2 = CryptFunctions.timeStampGetter();

                String encryptedServerMessage = CryptFunctions.encryptRSA(sessionKey + "," + words[2] + "," + TS2, CryptFunctions.getPublicKey("ClientCert"));
                String ticket = CryptFunctions.encryptRSA(words[0] + "," + words[2] + "," + TS2 + "," + sessionKey, CryptFunctions.getPublicKey(words[2] + "Cert"));

                logFile.println(CryptFunctions.timeStampGetter() + " KDC->Alice : " + sessionKey + ", " + words[2] + ", " + words[3]);
                logFile.println(CryptFunctions.timeStampGetter() + " KDC->Alice : " + encryptedServerMessage + ", " + ticket);
                serverOutput.println(encryptedServerMessage + ", " + ticket);
                break;
            }
        }
        logFile.close();
        clientSocket.close();
    }

    /**
     * Generates a 128 byte session key using the AES encryption method
     **/
    private static String sessionKeyGenerator() throws Exception {
        KeyGenerator keyGen = KeyGenerator.getInstance("AES");
        keyGen.init(128);
        SecretKey sessionKey = keyGen.generateKey();
        return Base64.getEncoder().encodeToString(sessionKey.getEncoded());
    }

}